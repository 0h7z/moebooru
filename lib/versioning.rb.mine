require 'history_change'
require 'history'

module ActiveRecord
  module Versioning
    def self.included(base)
      base.extend ClassMethods
      base.define_callbacks :after_undo
    end

    def remember_new
      @object_is_new = true
    end

    def get_group_by_id
      self[self.class.get_group_by_foreign_key]
    end

    # Get the current History object.  This is reused as long as we're operating on
    # the same group_by_obj (that is, they'll be displayed together in the history view).
    # Only call this when you're actually going to create HistoryChanges, or this will
    # leave behind empty Histories.
  private
    def get_current_history
      #p "get_current_history %s #%i" % [self.class.table_name, id]
      history = Thread.current[:versioning_history]
      if history
        #p "reuse? %s != %s, %i != %i" % [history.group_by_table, self.class.get_group_by_table_name, history.group_by_id, self.get_group_by_id]
        if history.group_by_table != self.class.get_group_by_table_name or 
          history.group_by_id != self.get_group_by_id then
          #p "don't reuse"
          Thread.current[:versioning_history] = nil
          history = nil
        else
          #p "reuse"
        end
      end

      if not history then
        options = {
          :group_by_table => self.class.get_group_by_table_name,
          :group_by_id => self.get_group_by_id,
          :user_id => Thread.current["danbooru-user_id"]
        }
        history = History.new(options)
        history.save!

        Thread.current[:versioning_history] = history
      end

      return history
    end

  public
    def save_versioned_attributes
      transaction do
        self.class.get_versioned_attributes.each { |att, options|
          # Always save all properties on creation.
          #
          # Don't use _changed?; it'll be true if a field was changed and then changed back,
          # in which case we must not create a change entry.
          old = self.__send__("%s_was" % att.to_s)
          new = self.__send__(att.to_s)

#          p "%s:  %s -> %s" % [att.to_s, old, new]
          next if old == new && !@object_is_new

          history = get_current_history
          h = HistoryChange.new(:table_name => self.class.table_name,
                          :remote_id => self.id,
                          :field => att.to_s,
                          :value => new,
                          :history_id => history.id)
          h.save!
        }
      end
    end

    def versioned_master_object
      parent = self.class.get_versioned_parent
      return nil if !parent
      type = Object.const_get(parent[:class].to_s.classify)
      foreign_key = parent[:foreign_key]
      id = self[foreign_key]
      type.find(id)
    end

    module ClassMethods
      # :default => If a default value is specified, initial changes (created with the
      # object) that set the value to the default will not be displayed in the UI.
      # This is also used by :allow_reverting_to_default.  This value can be set
      # to nil, which will match NULL.  Be sure at least one property has no default,
      # or initial changes will show up as a blank line in the UI.
      # 
      # :allow_reverting_to_default => By default, initial changes.  Fields with
      # :allow_reverting_to_default => true can be undone; the default value will
      # be treated as the previous value.
      def versioned(att, *options)
        if not @versioned_attributes
          @versioned_attributes = {}
          self.after_save :save_versioned_attributes
          self.after_create :remember_new
          self.after_destroy :delete_history_records

          self.versioning_display if not @versioning_display
        end

        @versioned_attributes[att] = *options || {}
      end

      # Configure the history display.
      #
      # :class => Group displayed changes with another class.
      # :foreign_key => Key within :class to display.
      # :controller, :action => Route for displaying the grouped class.
      #
      #   versioning_display :class => :pool
      #   versioning_display :class => :pool, :foreign_key => :pool_id, :action => "show"
      #   versioning_display :class => :pool, :foreign_key => :pool_id, :controller => Post
      def versioning_display(options = {})
        opt = {
          :class => self.to_s.to_sym,
          :controller => self.to_s,
          :action => "show",
        }.merge(options)

        if not opt[:foreign_key]
          if opt[:class] == self.to_s.to_sym
            opt[:foreign_key] = :id
          else
            reflection = self.reflections[opt[:class]]
            opt[:foreign_key] = reflection.klass.base_class.to_s.foreign_key.to_sym
          end
        end

        @versioning_display = opt
      end

      def get_versioning_group_by
        @versioning_display
      end

      def get_group_by_class
        cl = @versioning_display[:class].to_s.classify
        Object.const_get(cl)
      end

      def get_group_by_table_name
        get_group_by_class.table_name
      end

      def get_group_by_foreign_key
        @versioning_display[:foreign_key]
      end

      # Specify a parent table.  After a change is undone in this table, the
      # parent class will also receive an after_undo message.  If multiple
      # changes are undone together, changes to parent tables will always
      # be undone after changes to child tables.
      def versioned_parent(c, options = {})
        foreign_key = options[:foreign_key]
        foreign_key ||= self.reflections[c].klass.base_class.to_s.foreign_key
        foreign_key = foreign_key.to_sym
        @versioned_parent = {
          :class => c,
          :foreign_key => foreign_key
        }
      end

      def get_versioned_parent
        @versioned_parent
      end

      def get_versioned_attributes
        @versioned_attributes || {}
      end

      def get_versioned_attribute_options(field)
        get_versioned_attributes[field.to_sym]
      end

      # Add default histories for any new versioned properties.  Group the new fields
      # with existing histories for the same object, if any, so new properties don't
      # fill up the history as if they were new properties.
      def update_versioned_tables(c)
        table_name = c.table_name
        p "Updating %s ..." % [table_name]

        # Our schema doesn't allow us to apply single ON DELETE constraints, so use
        # a rule to do it.  This is Postgresql-specific.
        connection.execute <<-EOS
          CREATE OR REPLACE RULE delete_histories AS ON DELETE TO #{table_name}
          DO (
            DELETE FROM history_changes WHERE remote_id = OLD.id AND table_name = '#{table_name}';
            DELETE FROM histories WHERE group_by_id = OLD.id AND group_by_table = '#{table_name}';
          );
        EOS

        attributes_to_update = []

        c.get_versioned_attributes.each { |att, options|
          # If any histories already exist for this attribute, assume that it's already been updated.
          next if HistoryChange.find(:first, :conditions => ["table_name = ? AND field = ?", table_name, att.to_s])
          attributes_to_update << att
        }
p c.instance_methods(false)
p c.get_versioned_attributes
p attributes_to_update
        return if attributes_to_update.empty?

        transaction do
          current = 1
          count = c.count(:all)
          c.find(:all, :order => :id).each { |item|
            p "%i/%i" % [current, count]
            current += 1

            group_by_table = item.class.get_group_by_table_name
            group_by_id = item.get_group_by_id
            #p "group %s by %s" % [item.to_s, item.class.get_group_by_table_name.to_s]
            history = History.find(:first, :order => "id ASC",
                                   :conditions => ["group_by_table = ? AND group_by_id = ?", group_by_table, group_by_id])

            if not history
              #p "new history"
              options = {
                :group_by_table=> group_by_table,
                :group_by_id => group_by_id
              }
              options[:user_id] = item.user_id if item.respond_to?("user_id")
              options[:user_id] ||= 1
              history = History.new(options)
              history.save!
            end

            to_create = []
            attributes_to_update.each { |att|
              value = item.__send__(att.to_s)
              options = {
                :field => att.to_s,
                :value => value,
                :table_name => table_name,
                :remote_id => item.id,
                :history_id => history.id
              }

              escaped_options = {}
              options.each { |key,value|
                if value == nil
                  escaped_options[key] = "NULL"
                else
                  column = HistoryChange.columns_hash[key]
                  quoted_value = Base.connection.quote(value, column)
                  escaped_options[key] = quoted_value
                end
              }

              to_create += [escaped_options]
            }

            columns = to_create.first.map { |key,value| key.to_s }
            
            values = []
            to_create.each { |row|
              outrow = []
              columns.each { |col|
                val = row[col.to_sym]
                outrow += [val]
              }
              values += ["(#{outrow.join(",")})"]
            }
            sql = <<-EOS
              INSERT INTO history_changes (#{columns.join(", ")}) VALUES #{values.join(",")}
            EOS
            Base.connection.execute sql
          }
        end
      end

      def import_post_tag_history
        count = PostTagHistory.count(:all)
        current = 1
        PostTagHistory.find(:all, :order => "id ASC").each { |tag_history|
          p "%i/%i" % [current, count]
          current += 1

          prev = tag_history.previous

          tags = tag_history.tags.scan(/\S+/)
          metatags, tags = tags.partition {|x| x=~ /^(?:rating):/}
          tags = tags.sort.join(" ")

          rating = ""
          prev_rating = ""
          metatags.each do |metatag|
            case metatag
            when /^rating:([qse])/
              rating = $1
            end
          end

          if prev
            prev_tags = prev.tags.scan(/\S+/)
            prev_metatags, prev_tags = prev_tags.partition {|x| x=~ /^(?:-pool|pool|rating|parent):/}
            prev_tags = prev_tags.sort.join(" ")

            prev_metatags.each do |metatag|
              case metatag
              when /^rating:([qse])/
                prev_rating = $1
              end
            end
          end

          changed = false
          if tags != prev_tags or rating != prev_rating then
            h = History.new(:group_by_table => "posts",
                            :group_by_id => tag_history.post_id,
                            :user_id => tag_history.user_id || tag_history.post.user_id || 1,
                            :created_at => tag_history.created_at)
            h.save!
          end
          if tags != prev_tags then
            c = h.history_changes.new(:table_name => "posts",
                                     :remote_id => tag_history.post_id,
                                     :field => "cached_tags",
                                     :value => tags)
            c.save!
          end

          if rating != prev_rating then
            c = h.history_changes.new(:table_name => "posts",
                                     :remote_id => tag_history.post_id,
                                     :field => "rating",
                                     :value => rating)
            c.save!
          end
        }
      end

      def update_all_versioned_tables
        update_versioned_tables Pool
        update_versioned_tables PoolPost
        update_versioned_tables Post
        update_versioned_tables Tag
      end
    end
  end
end

ActiveRecord::Base.send :include, ActiveRecord::Versioning

